{
  "0": {
    "id": "0",
    "title": "Acknowledgements",
    "content": "Acknowledgements ScreenBEAM2 was original developed by Jiyang Yu, with substantial design input from Xinge Wang. We are grateful to Chenxi Qian for package wrapping up and maintainance. Funding Supports This work was supported by NIH grant. The work was also supported by St. Jude grants.",
    "url": "http://localhost:4000/docs/Acknowledgements.html",
    "relUrl": "/docs/Acknowledgements.html"
  },
  "1": {
    "id": "1",
    "title": "Installation",
    "content": "Installation Install blat You can install blat from conda: conda install -c bioconda blat which blat Install R package from github devtools::install(pkg=&#39;.&#39;, dependencies = T) devtools::install_deps(pkg = &quot;.&quot;, dependencies = TRUE) ## Install package dependencies if needed.",
    "url": "http://localhost:4000/docs/Installation.html",
    "relUrl": "/docs/Installation.html"
  },
  "2": {
    "id": "2",
    "title": "Tutorial",
    "content": "Tutorial ScreenBEAM2 is a R based tool which consists of three major parts for processing steps: 1. mapping long read sequence to short read libraries, 2. Quality control, data cleanning and data preprocessing for mapped raw counts data; 3. Differential representative analysis on gene level or shRNA level. Step1.Mapping to library Step1.1 Prepare raw fastq and library files Step1.2 Mapping and collecting raw counts Step1.3 Mapping qualtiy control Step2 Data annotation and data cleanning Step2.1 Create Metadata Step2.2 Combine mapping info to your metadata Step2.3 Data normalization and create Expressionset Step2.4 Qualtiy control for wrapped expressionsets Step2.5 Prepare tsv file for differential representation analysis Step3.Perform pairwise comparisons on Gene level Step4.Perform pairwise comparisons on shRNA level Step1.Mapping to library Step1.1 Prepare raw fastq and library files First of all, define your project name and create a project R object. This could be achieved by function ScreenBEAM.dir.create. note: Project object should be library based! One library per run of ScreenBEAM2! lib.name&lt;-&#39;[your_library_name_+_project_name]&#39; analysis.par&lt;-ScreenBEAM.dir.create(project_main_dir = &#39;./&#39;, lib_name = lib.name, DATE = T) analysis.par$par.path&lt;-analysis.par$out.dir analysis.par$par.name&lt;-paste0(&quot;analysis_par_&quot;,lib.name, &quot;.RData&quot;) load(paste0(par.path, par.name)) Create a table with all raw fastq files that are mapped to this library f&lt;-list.files(path=&quot;../201901/rawdata/Das_fastq/Lib_B/&quot;,patter=&quot;.fastq$&quot;,recursive=TRUE,full.names=TRUE) f&lt;-normalizePath(f) write.table(f,file=file.path(par.path,&quot;fastq_paths.txt&quot;),sep=&quot; t&quot;,quote=FALSE,row.names=FALSE,col.names=FALSE) Next, soft link your fastq file to analysis.par$out.dir.fastq folder. This step is ESSENTIAL, please DON’T move files directly, in case of losing your data. You can go to your analysis.par$out.dir.fastq folder, then run command: ln -s filepaths Put library csv file with file name “JJ_Das_LibB.csv” in the analysis.par$out.dir.library folder. The 1st column must be gRNA name and 2nd column must be sequence. Then go to analysis.par$out.dir.library folder and run following command to create fasta file for library. awk FNR-1 your_library.csv | awk -F &quot;,&quot; &#39;{print &quot;&gt;&quot;$1&quot; n&quot;$2}&#39; &gt; your_library.fa&quot; Then you could move forward to mapping and collecting raw counts step, which could be executed on cluster. Step1.2 Mapping and collecting raw counts first of all, please ensure blat was installed in your working environment, since we will be utilizing blat for mapping. (You can use blat version here on conda) Next, we wil need to execute ScreenBEAM.raw.count function in ScreenBEAM2 R package. This function will help mapping your fastq files to library and collect raw counts by calling BLAT from R. analysis.par&lt;-ScreenBEAM.raw.count(analysis.par) # suggest to save analysis.par now, because a lot of data has been created. save(analysis.par, file = paste0(par.path, par.name)) NOTE: Some fastq files are ultra big, you may need to chop them into small fastq files in order to execute them successfully. Step1.3 Mapping qualtiy control After mapping is done, please proceed your analysis back in interactive environment (such as R studio), and run command as follows: ScreenBEAM.mapping.QC(analysis.par) This will output a QC report for your library mapping, including mapping rate, mismatch rate, count boxplots, etc. Step2 Data annotation and data cleanning Step2.1 Create Metadata First of all, please have your Metadata information collected in an excel file, and saved it to analysis.par$out.dir.metadata. You could take following excel file as an example. Please note that, ID that could be matched to sampleID on fastq files is required,as well as proper group informations. meta &lt;-read.xlsx(file.path(analysis.par$out.dir.metadata,&quot;Metadata.xlsx&quot;), sheet = 1) dim(meta) raw&lt;-analysis.par$raw.count.table s.cur&lt;-data.frame(sampleID.full=names(raw)) #chop sample name into sectors s.cur&lt;-mutate(s.cur, sampleID=gsub(&#39;(.*)_(.*)_(.*)_(.*)_R1_001&#39;,&#39; 2&#39;,sampleID.full), HartwellID=as.numeric(gsub(&#39;(.*)_(.*)_(.*)_(.*)_R1_001&#39;,&#39; 1&#39;,sampleID.full)), HiseqSampleID=gsub(&#39;(.*)_(.*)_(.*)_(.*)_R1_001&#39;,&#39; 3&#39;,sampleID.full), HiseqLaneID=gsub(&#39;(.*)_(.*)_(.*)_(.*)_R1_001&#39;,&#39; 4&#39;,sampleID.full) )#this could be adjusted accordingly meta&lt;-left_join(s.cur,meta,by=&#39;sampleID&#39;) dim(meta) Check if there are duplicates in your metadata – this step is crucial because duplicates will affect following data manipulation. meta&lt;-mutate(meta,sampleName=paste(sampleID,HiseqLaneID,sep=&#39;_&#39;),index=paste(HiseqSampleID,HiseqLaneID,sep=&#39;_&#39;)) filter(meta,duplicated(sampleName)) filter(meta,duplicated(index)) dim(meta) Step2.2 Combine mapping info to your metadata Read mapping info and combine them in meta data: mapping&lt;-analysis.par$raw.summary mapping&lt;-mapping[,c(&#39;sample&#39;,&#39;total&#39;,&#39;n.matched&#39;)] names(mapping)[1]&lt;-&#39;sampleID.full&#39; mapping&lt;-mutate(mapping,mappingRate=n.matched/total,coverage.seq=round(n.matched/nrow(analysis.par$raw.count.table))) head(mapping) # calculate mapping statistics meta&lt;-left_join(meta,mapping,by=&quot;sampleID.full&quot;) unlink(file.path(analysis.par$out.dir.output.mapping,&#39;mapping.summary.xlsx&#39;)) write.xlsx(meta,file=file.path(analysis.par$out.dir.output.mapping,&#39;mapping.summary.xlsx&#39;),sheet=&#39;mapping&#39;) Add n.mismatch filter and Save eset raw data count.dist&lt;-as.data.frame(analysis.par$raw.count.dist) count.dist$sample&lt;-meta$sampleName[match(count.dist$sample,meta$sampleID.full)] names(count.dist)[2]&lt;-&#39;sampleName&#39; Step2.3 Data normalization and create Expressionset For this step you will need to perform data normalization and store different normalization method into eset. normalize.total&lt;-1e6 m&lt;-list(samples=meta,features=analysis.par$lib, count.dist=count.dist) save(m, file = paste0(par.path, &quot;raw.list.Rdata&quot;)) saveCountEset(m, save.path=analysis.par$out.dir.output.mapping, n.mismatch = 9) # n.mismatch should be adjusted according to mapping qc Step2.4 Qualtiy control for wrapped expressionsets Here we have a build-in QC function draw.eset.QC to facilitate quality control purpose. Each draw.eset.QC function will output a quality control report for following expression set. load(paste0(analysis.par$out.dir.output.mapping,&quot;count.9mm.raw.eset&quot;)); raw.9mm&lt;-count.Nmm.raw.eset # assign your eset with a more specific name draw.eset.QC(raw.9mm, outdir = analysis.par$out.dir.output.QC, intgroup = &#39;group&#39;, do.logtransform = T, prefix = &#39;raw.9mm_&#39;, choose_plot = c(&quot;heatmap&quot;, &quot;pca&quot;,&quot;density&quot;,&quot;correlation&quot;,&quot;meansd&quot;)) load(paste0(analysis.par$out.dir.output.mapping,&quot;count.9mm.normalized.eset.1M.eset&quot;)); norm.9mm&lt;-count.Nmm.normalized.eset draw.eset.QC(norm.9mm, outdir = analysis.par$out.dir.output.QC, intgroup = &#39;group&#39;, do.logtransform = T, prefix = &#39;norm.9mm_&#39;, choose_plot = c(&quot;heatmap&quot;, &quot;pca&quot;,&quot;density&quot;,&quot;correlation&quot;,&quot;meansd&quot;)) load(paste0(analysis.par$out.dir.output.mapping,&quot;count.maxmm.raw.eset&quot;)); raw.maxmm&lt;-count.maxmm.raw.eset draw.eset.QC(raw.maxmm, outdir = analysis.par$out.dir.output.QC, intgroup = &#39;group&#39;, do.logtransform = T, prefix = &#39;raw.maxmm_&#39;, choose_plot = c(&quot;heatmap&quot;, &quot;pca&quot;,&quot;density&quot;,&quot;correlation&quot;,&quot;meansd&quot;)) load(paste0(analysis.par$out.dir.output.mapping,&quot;count.maxmm.normalized.1M.eset&quot;)); norm.maxmm&lt;-count.maxmm.normalized.eset draw.eset.QC(norm.maxmm, outdir = analysis.par$out.dir.output.QC, intgroup = &#39;group&#39;, do.logtransform = T, prefix = &#39;norm.maxmm_&#39;, choose_plot = c(&quot;heatmap&quot;, &quot;pca&quot;,&quot;density&quot;,&quot;correlation&quot;,&quot;meansd&quot;)) Step2.5 Prepare tsv file for differential representation analysis Save normalized data and ids (gene/shRNA) in a tsv file for downstream analysis. first.2.column&lt;-data.frame(RNAid=analysis.par$lib$id, geneid=analysis.par$lib$gene) count.column&lt;-as.data.frame(exprs(norm.9mm)) count.column$RNAid&lt;-rownames(count.column) final.table&lt;-merge(first.2.column, count.column, by=&quot;RNAid&quot;) colnames(final.table)&lt;-c(&quot;rnaID&quot;,&quot;geneID&quot;, paste(meta$group,meta$replicate, sep = &quot;_&quot;)) write.table(final.table, file = paste0(analysis.par$out.dir.output.DR,&quot;YOUR_PROJECT_9mm_normalized.tsv&quot;), quote = F, row.names = F, sep=&#39; t&#39;) Step3.Perform pairwise comparisons on Gene level For whole genome libraries, it may cost sometime to run these pairwise comparisons sequentially. So we recommend to generate one R script for each comparisons and running them in parallel. Step4.Perform pairwise comparisons on shRNA level shRNA level comparison also give another layer of information when gene level comparisons are not that informative. Statistical significance could only be computed when there are 2 or more replicates in experinment design, otherwise only folder changes (FC) will be computed successfully. First of all, double check the group label in your comparisons are in eset$group info. unique.group&lt;-unique(eset$group) # group label in your eset d&lt;-openxlsx::read.xlsx(&quot;20191020_CRISPR_comparisons.xlsx&quot;) # comparisons that you want to perform all(unlist(d)%in%unique.group) # make sure all group label exists in unique.group compare.pairs&lt;-t(d) # your comparisons are required to be as follows Specify your input file: input.file&lt;-&quot;4cl_combined_withlib_normalized_50M.tsv&quot; Do comparisons by function ScreenBEAM.rna.level. de.rna.list&lt;-list() # create an empty list to store following analysis results for(i in 1:dim(compare.pairs)[2]){ case.groupname&lt;-compare.pairs[1,i] control.groupname&lt;-compare.pairs[2,i] case.sample.id&lt;-which(eset$group==compare.pairs[1,i]) control.sample.id&lt;-which(eset$group==compare.pairs[2,i]) case.postfix&lt;-LETTERS[seq(from=1, to=length(case.sample.id))] control.postfix&lt;-LETTERS[seq(from=1, to=length(control.sample.id))] control.samples&lt;-eset$group[control.sample.id] case.samples&lt;-eset$group[case.sample.id] de&lt;-ScreenBEAM.rna.level(input.file, control.samples = control.samples, case.samples = case.samples, control.groupname=control.groupname, case.groupname=case.groupname, gene.columnId=2, do.log2=TRUE, do.normalization=FALSE, filterLowCount=TRUE, filterBy=&#39;control&#39;,count.cutoff=8,family=gaussian,estimation.method=&#39;Bayesian&#39;) compare.name&lt;-paste0(case.groupname,&quot;.vs.&quot;,control.groupname) names(de)&lt;-paste(names(de), compare.name, sep = &quot;.&quot;) names(de)[1]&lt;-&quot;rnaID&quot; de.rna.list[[compare.name]]&lt;-de } save.image(&quot;DE.sgRNA.RData&quot;) #save your data Merge your results by “rnaID” and combine feature information from fData(eset). if(length(de.rna.list)&gt;1){ DR.RNA.DF&lt;-de.rna.list[[1]] for(i in 2:length(de.rna.list)){ DR.RNA.DF&lt;-merge(DR.RNA.DF, de.rna.list[[i]], by=&quot;rnaID&quot;,all.x = TRUE) } }else{ DR.RNA.DF&lt;-de.rna.list[[1]] } DR.RNA.DF&lt;-merge(DR.RNA.DF,fData(eset),by.x=&quot;rnaID&quot;,by.y=&quot;id&quot;) Clean up your data frame using function select. Save your analysis results. DR.RNA.DF.sel&lt;-dplyr::select(DR.RNA.DF, rnaID, gRNA.sequence:nchar, dplyr::starts_with(&#39;log2FC&#39;), dplyr::starts_with(&#39;Ave.&#39;) ) save.image(&quot;DE.sgRNA.RData&quot;) Output your result as an excel file. df&lt;-exprs(eset) DR.RNA.DF.sel&lt;-merge(DR.RNA.DF.sel,df,by.x=&quot;rnaID&quot;,by.y=&quot;row.names&quot;) openxlsx::write.xlsx(DR.RNA.DF.sel, &quot;4CL.2Lib.DR.sgRNA.xlsx&quot;)",
    "url": "http://localhost:4000/docs/Tutorial.html",
    "relUrl": "/docs/Tutorial.html"
  },
  "3": {
    "id": "3",
    "title": "Home",
    "content": "ScreenBEAM2 Gene-level meta-analysis of high-throughput functional genomics screens Get started now View it on GitHub Overview ScreenBEAM2 is a comprehensive analysis pipeline for CRISPR-Cas9 experinment data analysis, including functions from library mapping to pairwise comparisons. It is an updated version of ScreenBEAM which utilizes BLAT for library mapping, and incorporates useful data manipulating and quality control methods. Citing ScreenBEAM2 If ScreenBEAM2 is useful to your work, please cite the following paper: Yu J, Silva, J, Califano A. ScreenBEAM: a Novel Meta-Analysis Algorithm for Functional Genomics Screens via Bayesian Hierarchical Modeling. _Bioinformatics, 2015 Sep 28. pii: btv556. Contact The ScreenBEAM2 software is developed by Yu Lab at St. Jude Children’s Research Hospital. We’re very interested to hear feedback about using scMINER in your analysis. If you find any issues/bugs, or have any suggestions, please don’t hesitate to create issues in GitHub, or contact us directly.",
    "url": "http://localhost:4000/",
    "relUrl": "/"
  }
  
}
